<html><head><meta charset="utf-8"><title>std::memory_order</title><link href="../../css.css" rel="stylesheet" type="text/css"><script src="../../js.js" type="text/javascript"></script><style>.t-example-live-link {display:none !important} .t-sidebar-body {display:none}\nbody{min-width:0}\ndiv.mw-geshi{width:95%}\ndiv#content {width:auto !important} div#content{background-image:none; margin-left:0px;} .t-lines {background:inherit !important} pre, div.mw-geshi {width: 100% !important} body {background:white !important} div#content {width:100% !important} pre, div.mw-geshi {width:auto !important} .t-example-live-link, #mw-head, #cpp-footer-base {display:none !important} .t-navbar-menu > div {position:relative !important}</style></head><body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_atomic_memory_order skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <div class="noprint" id="mw-head">
            <div id="cpp-head-first-base">
                <div id="cpp-head-first">
                    <h5><a href="http://en.cppreference.com/">
                        cppreference.com                        </a></h5>
                    <div id="cpp-head-search">
                        
<!-- 0 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="/mwiki/index.php" id="searchform">
		<input name="title" type="hidden" value="Special:Search">
				<div id="simpleSearch">
						<input accesskey="f" id="searchInput" name="search" title="Search cppreference.com [f]">						<button id="searchButton" name="button" title="Search the pages for this text" type="submit"><img alt="Search" src="../../../mwiki/skins/cppreference2/images/search-ltr.png"></button>					</div>
			</form>
</div>

<!-- /0 -->
                    </div>
                    <div id="cpp-head-personal">
                        
<!-- 0 -->
<div class="" id="p-personal">
<span id="pt-createaccount"><a href="http://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&amp;returnto=cpp%2Fatomic%2Fmemory+order&amp;type=signup">Create account</a></span>	<div class="menu">
        <ul>
<li id="pt-login"><a accesskey="o" href="http://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&amp;returnto=cpp%2Fatomic%2Fmemory+order" title="You are encouraged to log in; however, it is not mandatory [o]">Log in</a></li>        </ul>
    </div>
</div>

<!-- /0 -->
                    </div>

                </div>
            </div>
            <div id="cpp-head-second-base">
                <div id="cpp-head-second">
                    <div id="cpp-head-tools-left">
                        
<!-- 0 -->
<div class="vectorTabs" id="p-namespaces">
	<h5>Namespaces</h5>
	<ul>
					<li class="selected" id="ca-nstab-main"><span><a accesskey="c" href="./memory_order.html" title="View the content page [c]">Page</a></span></li>
					<li id="ca-talk"><span><a accesskey="t" href="http://en.cppreference.com/w/Talk:cpp/atomic/memory_order" title="Discussion about the content page [t]">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div class="vectorMenu emptyPortlet" id="p-variants">
		<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
                    </div>
                    <div id="cpp-head-tools-right">
                        
<!-- 0 -->
<div class="vectorTabs" id="p-views">
	<h5>Views</h5>
	<ul>
					<li class="selected" id="ca-view"><span><a href="./memory_order.html">View</a></span></li>
					<li id="ca-edit"><span><a accesskey="e" href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit" title="You can edit this page. Please use the preview button before saving [e]">Edit</a></span></li>
					<li class="collapsible" id="ca-history"><span><a accesskey="h" href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=history" title="Past revisions of this page [h]">History</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div class="vectorMenu emptyPortlet" id="p-cactions">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 class="firstHeading" id="firstHeading"><span style="font-size:0.7em; line-height:130%">std::</span>memory_order</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>&lrm; | <a href="../atomic.html" title="cpp/atomic">atomic</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en"><div class="t-navbar" style=""><div class="t-navbar-sep">&nbsp;</div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table cellpadding="0" class="t-nv-begin" style="line-height:1.1em;">
<tbody><tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept.html" title="cpp/concept"> Library concepts</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html#Language_support" title="cpp/utility"> Language support library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="cpp/error"> Diagnostics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem"> Filesystem library</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical Specifications</a> </td></tr>
</tbody></table></div><div><span class="editsection noprint plainlinks" title="Edit this template"><a class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&amp;action=edit" rel="nofollow">[edit]</a></span></div></div></div></div><div class="t-navbar-sep">&nbsp;</div><div class="t-navbar-head"><a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a><div class="t-navbar-menu"><div><div><table cellpadding="0" class="t-nv-begin" style="">
<tbody><tr class="t-nv-h1"><td colspan="5"> Types</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic.html" title="cpp/atomic/atomic"><span class="t-lines"><span>atomic</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_is_lock_free.html" title="cpp/atomic/atomic is lock free"><span class="t-lines"><span>atomic_is_lock_free</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> Functions</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_store.html" title="cpp/atomic/atomic store"><span class="t-lines"><span>atomic_store</span><span>atomic_store_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_load.html" title="cpp/atomic/atomic load"><span class="t-lines"><span>atomic_load</span><span>atomic_load_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_exchange.html" title="cpp/atomic/atomic exchange"><span class="t-lines"><span>atomic_exchange</span><span>atomic_exchange_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_compare_exchange.html" title="cpp/atomic/atomic compare exchange"><span class="t-lines"><span>atomic_compare_exchange_weak</span><span>atomic_compare_exchange_weak_explicit</span><span>atomic_compare_exchange_strong</span><span>atomic_compare_exchange_strong_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_fetch_add.html" title="cpp/atomic/atomic fetch add"><span class="t-lines"><span>atomic_fetch_add</span><span>atomic_fetch_add_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_fetch_sub.html" title="cpp/atomic/atomic fetch sub"><span class="t-lines"><span>atomic_fetch_sub</span><span>atomic_fetch_sub_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_fetch_and.html" title="cpp/atomic/atomic fetch and"><span class="t-lines"><span>atomic_fetch_and</span><span>atomic_fetch_and_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_fetch_or.html" title="cpp/atomic/atomic fetch or"><span class="t-lines"><span>atomic_fetch_or</span><span>atomic_fetch_or_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_fetch_xor.html" title="cpp/atomic/atomic fetch xor"><span class="t-lines"><span>atomic_fetch_xor</span><span>atomic_fetch_xor_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> Atomic flags</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_flag.html" title="cpp/atomic/atomic flag"><span class="t-lines"><span>atomic_flag</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_flag_test_and_set.html" title="cpp/atomic/atomic flag test and set"><span class="t-lines"><span>atomic_flag_test_and_set</span><span>atomic_flag_test_and_set_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_flag_clear.html" title="cpp/atomic/atomic flag clear"><span class="t-lines"><span>atomic_flag_clear</span><span>atomic_flag_clear_explicit</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> Initialization</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_init.html" title="cpp/atomic/atomic init"><span class="t-lines"><span>atomic_init</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./ATOMIC_VAR_INIT.html" title="cpp/atomic/ATOMIC VAR INIT"><span class="t-lines"><span>ATOMIC_VAR_INIT</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./ATOMIC_FLAG_INIT.html" title="cpp/atomic/ATOMIC FLAG INIT"><span class="t-lines"><span>ATOMIC_FLAG_INIT</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> Memory ordering</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><strong class="selflink"><span class="t-lines"><span>memory_order</span></span></strong></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./kill_dependency.html" title="cpp/atomic/kill dependency"><span class="t-lines"><span>kill_dependency</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence"><span class="t-lines"><span>atomic_thread_fence</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="./atomic_signal_fence.html" title="cpp/atomic/atomic signal fence"><span class="t-lines"><span>atomic_signal_fence</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
</tbody></table></div><div><span class="editsection noprint plainlinks" title="Edit this template"><a class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/atomic/navbar_content&amp;action=edit" rel="nofollow">[edit]</a></span></div></div></div></div><div class="t-navbar-sep">&nbsp;</div></div>
<table class="t-dcl-begin"><tbody>
<tr class="t-dsc-header">
<td> <div>Defined in header <code><a href="../header/atomic.html" title="cpp/header/atomic">&lt;atomic&gt;</a></code>
 </div></td>
<td></td>
<td></td>
</tr>
</tbody>
<tbody class="t-dcl-rev">
<tr class="t-dcl t-since-cxx11 t-until-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">typedef</span> <span class="kw2">enum</span> memory_order <span class="br0">{</span><br>
<p>&nbsp; &nbsp; memory_order_relaxed,<br>
&nbsp; &nbsp; memory_order_consume,<br>
&nbsp; &nbsp; memory_order_acquire,<br>
&nbsp; &nbsp; memory_order_release,<br>
&nbsp; &nbsp; memory_order_acq_rel,<br>
&nbsp; &nbsp; memory_order_seq_cst<br>
</p>
<span class="br0">}</span> memory_order<span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx20">(until C++20)</span> </td>
</tr>
<tr class="t-dcl t-since-cxx20">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw2">enum</span> <span class="kw1">class</span> memory_order <span class="sy4">:</span> <span class="coMULTI">/*unspecified*/</span> <span class="br0">{</span><br>
<p>&nbsp; &nbsp; relaxed, consume, acquire, release, acq_rel, seq_cst<br>
<span class="br0">}</span><span class="sy4">;</span><br>
<span class="kw1">inline</span> <span class="kw4">constexpr</span> memory_order memory_order_relaxed <span class="sy1">=</span> memory_order<span class="sy4">::</span><span class="me2">relaxed</span><span class="sy4">;</span><br>
<span class="kw1">inline</span> <span class="kw4">constexpr</span> memory_order memory_order_consume <span class="sy1">=</span> memory_order<span class="sy4">::</span><span class="me2">consume</span><span class="sy4">;</span><br>
<span class="kw1">inline</span> <span class="kw4">constexpr</span> memory_order memory_order_acquire <span class="sy1">=</span> memory_order<span class="sy4">::</span><span class="me2">acquire</span><span class="sy4">;</span><br>
<span class="kw1">inline</span> <span class="kw4">constexpr</span> memory_order memory_order_release <span class="sy1">=</span> memory_order<span class="sy4">::</span><span class="me2">release</span><span class="sy4">;</span><br>
<span class="kw1">inline</span> <span class="kw4">constexpr</span> memory_order memory_order_acq_rel <span class="sy1">=</span> memory_order<span class="sy4">::</span><span class="me2">acq_rel</span><span class="sy4">;</span><br>
</p>
<span class="kw1">inline</span> <span class="kw4">constexpr</span> memory_order memory_order_seq_cst <span class="sy1">=</span> memory_order<span class="sy4">::</span><span class="me2">seq_cst</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td>
</tr>
</tbody><tbody>
<tr class="t-dcl-sep"><td></td><td></td><td></td></tr>
</tbody></table>
<p><code>std::memory_order</code> specifies how regular, non-atomic memory accesses are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.
</p><p>The default behavior of all atomic operations in the  library provides for <i>sequentially consistent ordering</i> (see discussion below). That default can hurt performance, but the library&#39;s atomic operations can be given an additional <code>std::memory_order</code> argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce for that operation.
</p>
<table class="toc" id="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a class="internal" href="#" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Constants"><span class="tocnumber">1</span> <span class="toctext">Constants</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Formal_description"><span class="tocnumber">2</span> <span class="toctext">Formal description</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Sequenced-before"><span class="tocnumber">2.1</span> <span class="toctext">Sequenced-before</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Carries_dependency"><span class="tocnumber">2.2</span> <span class="toctext">Carries dependency</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Modification_order"><span class="tocnumber">2.3</span> <span class="toctext">Modification order</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Release_sequence"><span class="tocnumber">2.4</span> <span class="toctext">Release sequence</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Dependency-ordered_before"><span class="tocnumber">2.5</span> <span class="toctext">Dependency-ordered before</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Inter-thread_happens-before"><span class="tocnumber">2.6</span> <span class="toctext">Inter-thread happens-before</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Happens-before"><span class="tocnumber">2.7</span> <span class="toctext">Happens-before</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Visible_side-effects"><span class="tocnumber">2.8</span> <span class="toctext">Visible side-effects</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Consume_operation"><span class="tocnumber">2.9</span> <span class="toctext">Consume operation</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Acquire_operation"><span class="tocnumber">2.10</span> <span class="toctext">Acquire operation</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Release_operation"><span class="tocnumber">2.11</span> <span class="toctext">Release operation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Explanation"><span class="tocnumber">3</span> <span class="toctext">Explanation</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Relaxed_ordering"><span class="tocnumber">3.1</span> <span class="toctext">Relaxed ordering</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Release-Acquire_ordering"><span class="tocnumber">3.2</span> <span class="toctext">Release-Acquire ordering</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Release-Consume_ordering"><span class="tocnumber">3.3</span> <span class="toctext">Release-Consume ordering</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Sequentially-consistent_ordering"><span class="tocnumber">3.4</span> <span class="toctext">Sequentially-consistent ordering</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Relationship_with_volatile"><span class="tocnumber">4</span> <span class="toctext">Relationship with <span><span><span>volatile</span></span></span></span></a></li>
<li class="toclevel-1 tocsection-20"><a href="#See_also"><span class="tocnumber">5</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-21"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=1" title="Edit section: Constants">edit</a>]</span> <span class="mw-headline" id="Constants">Constants</span></h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc-header">
<td colspan="2"> <div>Defined in header <code>&lt;atomic&gt;</code> </div>
</td></tr>

<tr class="t-dsc-hitem">
<td>  Value
</td>
<td>  Explanation
</td></tr>


<tr class="t-dsc">
<td>  <code>memory_order_relaxed</code>
</td>
<td>  Relaxed operation: there are no synchronization or ordering constraints imposed on other reads or writes, only this operation&#39;s atomicity is guaranteed (see <a href="#Relaxed_ordering">Relaxed ordering</a> below)
</td></tr>


<tr class="t-dsc">
<td>  <code>memory_order_consume</code>
</td>
<td>  A load operation with this memory order performs a <i>consume operation</i> on the affected memory location: no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only (see <a href="#Release-Consume_ordering">Release-Consume ordering</a> below)
</td></tr>


<tr class="t-dsc">
<td>  <code>memory_order_acquire</code>
</td>
<td>  A load operation with this memory order performs the <i>acquire operation</i> on the affected memory location: no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread (see <a href="#Release-Acquire_ordering">Release-Acquire ordering</a> below)
</td></tr>


<tr class="t-dsc">
<td>  <code>memory_order_release</code>
</td>
<td>  A store operation with this memory order performs the <i>release operation</i>: no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable (see <a href="#Release-Acquire_ordering">Release-Acquire ordering</a> below) and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic (see <a href="#Release-Consume_ordering">Release-Consume ordering</a> below).
</td></tr>


<tr class="t-dsc">
<td>  <code>memory_order_acq_rel</code>
</td>
<td>  A read-modify-write operation with this memory order is both an <i>acquire operation</i> and a <i>release operation</i>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.
</td></tr>


<tr class="t-dsc">
<td>  <code>memory_order_seq_cst</code>
</td>
<td>  A load operation with this memory order performs an  <i>acquire operation</i>, a store performs a <i>release operation</i>, and read-modify-write performs both an <i>acquire operation</i> and a <i>release operation</i>, plus a single total order exists in which all threads observe all modifications in the same order (see <a href="#Sequentially-consistent_ordering">Sequentially-consistent ordering</a> below)
</td></tr>

</tbody></table>
<h3><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=2" title="Edit section: Formal description">edit</a>]</span> <span class="mw-headline" id="Formal_description">Formal description</span></h3>
<p>Inter-thread synchronization and memory ordering determine how <i>evaluations</i> and <i>side effects</i> of expressions are ordered between different threads of execution. They are defined in the following terms:
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=3" title="Edit section: Sequenced-before">edit</a>]</span> <span class="mw-headline" id="Sequenced-before">Sequenced-before</span></h4>
<p>Within the same thread, evaluation A may be <i>sequenced-before</i> evaluation B, as described in <a href="../language/eval_order.html" title="cpp/language/eval order">evaluation order</a>.
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=4" title="Edit section: Carries dependency">edit</a>]</span> <span class="mw-headline" id="Carries_dependency">Carries dependency</span></h4>
<p>Within the same thread, evaluation A that is <i>sequenced-before</i> evaluation B may also carry a dependency into B (that is, B depends on A), if any of the following is true
</p>
<div class="t-li1"><span class="t-li">1)</span> The value of A is used as an operand of B, <b>except</b></div>
<div class="t-li2"><span class="t-li">a)</span> if B is a call to <span class="t-lc"><a href="./kill_dependency.html" title="cpp/atomic/kill dependency">std::kill_dependency</a></span></div>
<div class="t-li2"><span class="t-li">b)</span> if A is the left operand of the built-in <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;&amp;</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">||</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy4">?:</span></span></span>, or <span class="t-c"><span class="mw-geshi cpp source-cpp">,</span></span> operators.</div>
<div class="t-li1"><span class="t-li">2)</span> A writes to a scalar object M, B reads from M</div>
<div class="t-li1"><span class="t-li">3)</span> A carries dependency into another evaluation X, and X carries dependency into B</div>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=5" title="Edit section: Modification order">edit</a>]</span> <span class="mw-headline" id="Modification_order">Modification order</span></h4>
<p>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.
</p><p>The following four requirements are guaranteed for all atomic operations:
</p>
<div class="t-li1"><span class="t-li">1)</span> <b>Write-write coherence</b>: If evaluation A that modifies some atomic M (a write) <i>happens-before</i> evaluation B that modifies M, then A appears earlier than B in the <i>modification order</i> of M</div>
<div class="t-li1"><span class="t-li">2)</span> <b>Read-read coherence</b>: if a value computation A of some atomic M (a read) <i>happens-before</i> a value computation B on M, and if the value of A comes from a write X on M, then the value of B is either the value stored by X, or the value stored by a side effect Y on M that appears later than X in the <i>modification order</i> of M.</div>
<div class="t-li1"><span class="t-li">3)</span> <b>Read-write coherence</b>: if a value computation A of some atomic M (a read) <i>happens-before</i> an operation B on M (a write), then the value of A comes from a side-effect (a write) X that appears earlier than B in the <i>modification order</i> of M</div>
<div class="t-li1"><span class="t-li">4)</span> <b>Write-read coherence</b>: if a side effect (a write) X on an atomic object M <i>happens-before</i> a value computation (a read) B of M, then the evaluation B shall take its value from X or from a side effect Y that follows X in the modification order of M</div>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=6" title="Edit section: Release sequence">edit</a>]</span> <span class="mw-headline" id="Release_sequence">Release sequence</span></h4>
<p>After a <i>release operation</i> A is performed on an atomic object M, the longest continuous subsequence of the modification order of M that consists of
</p>
<div class="t-li1"><span class="t-li">1)</span> Writes performed by the same thread that performed A</div>
<div class="t-li1"><span class="t-li">2)</span> Atomic read-modify-write operations made to M by any thread</div>
<p>is known as <i>release sequence headed by A</i>
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=7" title="Edit section: Dependency-ordered before">edit</a>]</span> <span class="mw-headline" id="Dependency-ordered_before">Dependency-ordered before</span></h4>
<p>Between threads, evaluation A is <i>dependency-ordered before</i> evaluation B if any of the following is true
</p>
<div class="t-li1"><span class="t-li">1)</span> A performs a <i>release operation</i> on some atomic M, and, in a different thread, B performs a <i>consume operation</i> on the same atomic M, and B reads a value written by any part of the release sequence headed by A.</div>
<div class="t-li1"><span class="t-li">2)</span> A is dependency-ordered before X and X carries a dependency into B.</div>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=8" title="Edit section: Inter-thread happens-before">edit</a>]</span> <span class="mw-headline" id="Inter-thread_happens-before">Inter-thread happens-before</span></h4>
<p>Between threads, evaluation A <i>inter-thread happens before</i> evaluation B if any of the following is true
</p>
<div class="t-li1"><span class="t-li">1)</span> A <i>synchronizes-with</i> B</div>
<div class="t-li1"><span class="t-li">2)</span> A is <i>dependency-ordered before</i> B</div>
<div class="t-li1"><span class="t-li">3)</span> A <i>synchronizes-with</i> some evaluation X, and X is <i>sequenced-before</i> B</div>
<div class="t-li1"><span class="t-li">3)</span> A is <i>sequenced-before</i> some evaluation X, and X <i>inter-thread happens-before</i> B</div>
<div class="t-li1"><span class="t-li">4)</span> A <i>inter-thread happens-before</i> some evaluation X, and X <i>inter-thread happens-before</i> B</div>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=9" title="Edit section: Happens-before">edit</a>]</span> <span class="mw-headline" id="Happens-before">Happens-before</span></h4>
<p>Regardless of threads, evaluation A <i>happens-before</i> evaluation B if any of the following is true:
</p>
<div class="t-li1"><span class="t-li">1)</span> A is <i>sequenced-before</i> B</div>
<div class="t-li1"><span class="t-li">2)</span> A <i>inter-thread happens before</i> B</div>
<p>The implementation is required to ensure that the <i>happens-before</i> relation is acyclic, by introducing additional synchronization if necessary (it can only be necessary if a consume operation is involved, see <a class="external text" href="../../../../www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf" rel="nofollow">Batty et al</a>)
</p><p>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a <a href="../language/memory_model.html" title="cpp/language/memory model">data race</a>) unless there exists a <i>happens-before</i> relationship between these two evaluations.
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=10" title="Edit section: Visible side-effects">edit</a>]</span> <span class="mw-headline" id="Visible_side-effects">Visible side-effects</span></h4>
<p>The side-effect A on a scalar M (a write) is <i>visible</i> with respect to value computation B on M (a read) if both of the following are true:
</p>
<div class="t-li1"><span class="t-li">1)</span> A <i>happens-before</i> B</div>
<div class="t-li1"><span class="t-li">2)</span> There is no other side effect X to M where A <i>happens-before</i> X and X <i>happens-before</i> B</div>
<p>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset of the side-effects to M, in <i>modification order</i>, where B does not <i>happen-before</i> it is known as the <i>visible sequence of side-effects</i>. (the value of M, determined by B, will be the value stored by one of these side effects)
</p><p>Note: inter-thread synchronization boils down to preventing data races (by establishing happens-before relationships) and defining which side effects become visible under what conditions
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=11" title="Edit section: Consume operation">edit</a>]</span> <span class="mw-headline" id="Consume_operation">Consume operation</span></h4>
<p>Atomic load with <code>memory_order_consume</code> or stronger is a consume operation. Note that <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span> imposes stronger synchronization requirements than a consume operation.
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=12" title="Edit section: Acquire operation">edit</a>]</span> <span class="mw-headline" id="Acquire_operation">Acquire operation</span></h4>
<p>Atomic load with <code>memory_order_acquire</code> or stronger is an acquire operation. The lock() operation on a <a href="../concept/Mutex.html" title="cpp/concept/Mutex"><code>Mutex</code></a> is also an acquire operation. Note that <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span> imposes stronger synchronization requirements than an acquire operation.
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=13" title="Edit section: Release operation">edit</a>]</span> <span class="mw-headline" id="Release_operation">Release operation</span></h4>
<p>Atomic store with <code>memory_order_release</code> or stronger is a release operation. The unlock() operation on a <a href="../concept/Mutex.html" title="cpp/concept/Mutex"><code>Mutex</code></a> is also a release operation. Note that <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span> imposes stronger synchronization requirements than a release operation.
</p>
<h3><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=14" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span></h3>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=15" title="Edit section: Relaxed ordering">edit</a>]</span> <span class="mw-headline" id="Relaxed_ordering">Relaxed ordering</span></h4>
<p>Atomic operations tagged <span class="t-c"><span class="mw-geshi cpp source-cpp">memory_order_relaxed</span></span> are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.
</p><p>For example, with <code>x</code> and <code>y</code> initially zero,
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// Thread 1:</span>
r1 <span class="sy1">=</span> y.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// A</span>
x.<span class="me1">store</span><span class="br0">(</span>r1, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// B</span>
<span class="co1">// Thread 2:</span>
r2 <span class="sy1">=</span> x.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// C </span>
y.<span class="me1">store</span><span class="br0">(</span><span class="nu0">42</span>, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// D</span></pre></div></div>
<p>is allowed to produce <code>r1 == r2 == 42</code> because, although A is <i>sequenced-before</i> B within thread 1 and C is <i>sequenced before</i> D within thread 2, nothing prevents D from appearing before A in the modification order of y, and B from appearing before C in the modification order of x. The side-effect of D on y could be visible to the load A in Thread 1  while the side effect of B on x could be visible to the load C in Thread 2. In particular, this may occur if D is completed before C in thread 2, either due to compiler reordering or at runtime.
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx14"><td>
<p>Even with relaxed memory model, out-of-thin-air values are not allowed to circularly depend on their own computations, for example, with <code>x</code> and <code>y</code> initially zero,
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// Thread 1:</span>
r1 <span class="sy1">=</span> x.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span>
<span class="kw1">if</span> <span class="br0">(</span>r1 <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span> y.<span class="me1">store</span><span class="br0">(</span>r1, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span>
<span class="co1">// Thread 2:</span>
r2 <span class="sy1">=</span> y.<span class="me1">load</span><span class="br0">(</span>memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span>
<span class="kw1">if</span> <span class="br0">(</span>r2 <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span> x.<span class="me1">store</span><span class="br0">(</span><span class="nu0">42</span>, memory_order_relaxed<span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<p>is not allowed to produce <code>r1 == r2 == 42</code> since the store of 42 to y is only possible if the store to x stores 42, which circularly depends on the store to y storing 42. Note that until C++14, this was technically allowed by the specification, but not recommended for implementors.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td></tr>
</tbody></table>
<p>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters of <span class="t-lc"><a href="../memory/shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></span>, since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor)
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;vector&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
&nbsp;
<a href="./atomic.html"><span class="kw2066">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> cnt <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">1000</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        cnt.<span class="me1">fetch_add</span><span class="br0">(</span><span class="nu0">1</span>, std<span class="sy4">::</span><span class="me2">memory_order_relaxed</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1269">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span> <span class="br0">{</span>
        v.<span class="me1">emplace_back</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">auto</span><span class="sy3">&amp;</span> t <span class="sy4">:</span> v<span class="br0">)</span> <span class="br0">{</span>
        t.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;Final counter value is &quot;</span> <span class="sy1">&lt;&lt;</span> cnt <span class="sy1">&lt;&lt;</span> <span class="st0">&#39;<span class="es1">\n</span>&#39;</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="text source-text"><pre class="de1">Final counter value is 10000</pre></div></div> 
</div>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=16" title="Edit section: Release-Acquire ordering">edit</a>]</span> <span class="mw-headline" id="Release-Acquire_ordering">Release-Acquire ordering</span></h4>
<p>If an atomic store in thread A is tagged <span class="t-c"><span class="mw-geshi cpp source-cpp">memory_order_release</span></span> and an atomic load in thread B from the same variable is tagged <span class="t-c"><span class="mw-geshi cpp source-cpp">memory_order_acquire</span></span>, all memory writes (non-atomic and relaxed atomic) that <i>happened-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to memory.
</p><p>The synchronization is established only between the threads <i>releasing</i> and <i>acquiring</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</p><p>On strongly-ordered systems (x86, SPARC TSO, IBM mainframe), release-acquire ordering is automatic for the majority of operations. No additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from moving non-atomic stores past the atomic store-release or perform non-atomic loads earlier than the atomic load-acquire). On weakly-ordered systems (ARM, Itanium, PowerPC), special CPU load or memory fence instructions have to be used.
</p><p>Mutual exclusion locks (such as <span class="t-lc"><a href="../thread/mutex.html" title="cpp/thread/mutex">std::mutex</a></span> or <a href="./atomic_flag.html" title="cpp/atomic/atomic flag">atomic spinlock</a>) are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
&nbsp;
<a href="./atomic.html"><span class="kw2066">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">&quot;Hello&quot;</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, std<span class="sy4">::</span><span class="me2">memory_order_release</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_acquire</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw774">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">&quot;Hello&quot;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
    <a href="../error/assert.html"><span class="kw774">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<div class="t-example"><p> The following example demonstrates transitive release-acquire ordering across three threads
 </p><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<a href="../container/vector.html"><span class="kw1269">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> data<span class="sy4">;</span>
<a href="./atomic.html"><span class="kw2066">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> flag <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> thread_1<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    data.<span class="me1">push_back</span><span class="br0">(</span><span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span>
    flag.<span class="me1">store</span><span class="br0">(</span><span class="nu0">1</span>, std<span class="sy4">::</span><span class="me2">memory_order_release</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> thread_2<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> expected<span class="sy1">=</span><span class="nu0">1</span><span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>flag.<span class="me1">compare_exchange_strong</span><span class="br0">(</span>expected, <span class="nu0">2</span>, std<span class="sy4">::</span><span class="me2">memory_order_acq_rel</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        expected <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> thread_3<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span>flag.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_acquire</span><span class="br0">)</span> <span class="sy1">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw774">assert</span></a><span class="br0">(</span>data.<span class="me1">at</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// will never fire</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>thread_1<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>thread_2<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>thread_3<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=17" title="Edit section: Release-Consume ordering">edit</a>]</span> <span class="mw-headline" id="Release-Consume_ordering">Release-Consume ordering</span></h4>
<p>If an atomic store in thread A is tagged <span class="t-c"><span class="mw-geshi cpp source-cpp">memory_order_release</span></span> and an atomic load in thread B from the same variable is tagged <span class="t-c"><span class="mw-geshi cpp source-cpp">memory_order_consume</span></span>, all memory writes (non-atomic and relaxed atomic) that are <i>dependency-ordered-before</i> the atomic store from the point of view of thread A, become <i>visible side-effects</i> within those operations in thread B into which the load operation <i>carries dependency</i>, that is, once the atomic load is completed, those operators and functions in thread B that use the value obtained from the load are guaranteed to see what thread A wrote to memory.
</p><p>The synchronization is established only between the threads <i>releasing</i> and <i>consuming</i> the same atomic variable. Other threads can see different order of memory accesses than either or both of the synchronized threads.
</p><p>On all mainstream CPUs other than DEC Alpha, dependency ordering is automatic, no additional CPU instructions are issued for this synchronization mode, only certain compiler optimizations are affected (e.g. the compiler is prohibited from performing speculative loads on the objects that are involved in the dependency chain). 
</p><p>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is <a class="extiw" href="https://en.wikipedia.org/wiki/Read-copy-update" title="enwiki:Read-copy-update">rcu_dereference</a>.
</p><p>See also <span class="t-lc"><a href="./kill_dependency.html" title="cpp/atomic/kill dependency">std::kill_dependency</a></span> and <a href="../language/attributes.html" title="cpp/language/attributes">[[carries_dependency]]</a> for fine-grained dependency chain control.
</p><p>Note that currently (2/2015) no known production compilers track dependency chains: consume operations are lifted to acquire operations.
</p>
 <table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<p>The specification of release-consume ordering is being revised, and the use of  <code>memory_order_consume</code> is temporarily discouraged.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<div class="t-example"><p> This example demonstrates dependency-ordered synchronization for pointer-mediated publication: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.
 </p><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
&nbsp;
<a href="./atomic.html"><span class="kw2066">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span> ptr<span class="sy4">;</span>
<span class="kw4">int</span> data<span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> producer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p  <span class="sy1">=</span> new <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">&quot;Hello&quot;</span><span class="br0">)</span><span class="sy4">;</span>
    data <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    ptr.<span class="me1">store</span><span class="br0">(</span>p, std<span class="sy4">::</span><span class="me2">memory_order_release</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> consumer<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy2">*</span> p2<span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span><span class="br0">(</span>p2 <span class="sy1">=</span> ptr.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_consume</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw774">assert</span></a><span class="br0">(</span><span class="sy2">*</span>p2 <span class="sy1">==</span> <span class="st0">&quot;Hello&quot;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// never fires: *p2 carries dependency from ptr</span>
    <a href="../error/assert.html"><span class="kw774">assert</span></a><span class="br0">(</span>data <span class="sy1">==</span> <span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// may or may not fire: data does not carry dependency from ptr</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> t1<span class="br0">(</span>producer<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> t2<span class="br0">(</span>consumer<span class="br0">)</span><span class="sy4">;</span>
    t1.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> t2.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<p><br>
</p>
<h4><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=18" title="Edit section: Sequentially-consistent ordering">edit</a>]</span> <span class="mw-headline" id="Sequentially-consistent_ordering">Sequentially-consistent ordering</span></h4>
<p>Atomic operations tagged <span class="t-c"><span class="mw-geshi cpp source-cpp">memory_order_seq_cst</span></span> not only order memory the same way as release/acquire ordering (everything that <i>happened-before</i> a store in one thread becomes a <i>visible side effect</i> in the thread that did a load), but also establish a <i>single total modification order</i> of all atomic operations that are so tagged.
</p><p>Formally,
</p><p>Each <code>memory_order_seq_cst</code> operation B that loads from atomic variable M, observes one of the following:
</p>
<ul><li> the result of the last operation A that modified M, which appears before B in the single total order
</li><li> OR, if there was such an A, B may observe the result of some modification on M that is not <code>memory_order_seq_cst</code> and does not <i>happen-before</i> A
</li><li> OR, if there wasn&#39;t such an A, B may observe the result of some unrelated modification of M that is not <code>memory_order_seq_cst</code>
</li></ul>
<p>If there was a <code>memory_order_seq_cst</code> <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span> operation X <i>sequenced-before</i> B, then B observes one of the following:
</p>
<ul><li> the last <code>memory_order_seq_cst</code> modification of M that appears before X in the single total order
</li><li> some unrelated modification of M that appears later in M&#39;s modification order
</li></ul>
<p>For a pair of atomic operations on M called A and B, where A writes and B reads M&#39;s value, if there are two <code>memory_order_seq_cst</code> <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span>s X and Y, and if A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order, then B observes either:
</p>
<ul><li> the effect of A
</li><li> some unrelated modification of M that appears after A in M&#39;s modification order
</li></ul>
<p>For a pair of atomic modifications of M called A and B, B occurs after A in M&#39;s modification order if 
</p>
<ul><li> there is a <code>memory_order_seq_cst</code> <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span> X such that A is <i>sequenced-before</i> X and X appears before B in the Single Total Order
</li><li> or, there is a <code>memory_order_seq_cst</code> <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span> Y such that Y is <i>sequenced-before</i> B and A appears before Y in the Single Total Order
</li><li> or, there are <code>memory_order_seq_cst</code> <span class="t-lc"><a href="./atomic_thread_fence.html" title="cpp/atomic/atomic thread fence">std::atomic_thread_fence</a></span>s X and Y such that A is <i>sequenced-before</i> X, Y is <i>sequenced-before</i> B, and X appears before Y in the Single Total Order.
</li></ul>
<p>Note that this means that:
</p>
<div class="t-li1"><span class="t-li">1)</span> as soon as atomic operations that are not tagged <code>memory_order_seq_cst</code> enter the picture, the sequential consistency is lost</div>
<div class="t-li1"><span class="t-li">2)</span> the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (<i>sequenced-before</i> is not a cross-thread relationship, unlike <i>happens-before</i>)</div>
<p>Sequential ordering may be necessary for multiple producer-multiple consumer situations where all consumers must observe the actions of all producers occurring in the same order.
</p><p>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.
</p>
<div class="t-example"><p> This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads <code>c</code> and <code>d</code> to observe changes to the atomics <code>x</code> and <code>y</code> in opposite order.
 </p><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div class="mw-geshi" dir="ltr" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;thread&gt;</span>
<span class="co2">#include &lt;atomic&gt;</span>
<span class="co2">#include &lt;cassert&gt;</span>
&nbsp;
<a href="./atomic.html"><span class="kw2066">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> x <span class="sy1">=</span> <span class="br0">{</span><span class="kw2">false</span><span class="br0">}</span><span class="sy4">;</span>
<a href="./atomic.html"><span class="kw2066">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">bool</span><span class="sy1">&gt;</span> y <span class="sy1">=</span> <span class="br0">{</span><span class="kw2">false</span><span class="br0">}</span><span class="sy4">;</span>
<a href="./atomic.html"><span class="kw2066">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> write_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    x.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> write_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    y.<span class="me1">store</span><span class="br0">(</span><span class="kw2">true</span>, std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> read_x_then_y<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>x.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>y.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> read_y_then_x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span><span class="sy3">!</span>y.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span>
        <span class="sy4">;</span>
    <span class="kw1">if</span> <span class="br0">(</span>x.<span class="me1">load</span><span class="br0">(</span>std<span class="sy4">::</span><span class="me2">memory_order_seq_cst</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="sy2">++</span>z<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> a<span class="br0">(</span>write_x<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> b<span class="br0">(</span>write_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> c<span class="br0">(</span>read_x_then_y<span class="br0">)</span><span class="sy4">;</span>
    <a href="../thread/thread.html"><span class="kw2139">std::<span class="me2">thread</span></span></a> d<span class="br0">(</span>read_y_then_x<span class="br0">)</span><span class="sy4">;</span>
    a.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> b.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> c.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> d.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <a href="../error/assert.html"><span class="kw774">assert</span></a><span class="br0">(</span>z.<span class="me1">load</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// will never happen</span>
<span class="br0">}</span></pre></div></div>
<p><br> 
</p>
</div>
<h3><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=19" title="Edit section: Relationship with volatile">edit</a>]</span> <span class="mw-headline" id="Relationship_with_volatile">Relationship with <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span></span></span></h3>
<p>Within a thread of execution, accesses (reads and writes) through <a href="../language/cv.html" title="cpp/language/cv">volatile glvalues</a> cannot be reordered past observable side-effects (including other volatile accesses) that are <i>sequenced-before</i> or <i>sequenced-after</i> within the same thread, but this order is not guaranteed to be observed by another thread, since volatile access does not establish inter-thread synchronization.
</p><p>In addition, volatile accesses are not atomic (concurrent read and write is a <a href="../language/memory_model.html" title="cpp/language/memory model">data race</a>) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).
</p><p>One notable exception is Visual Studio, where, with default settings, every volatile write has release semantics and every volatile read has acquire semantics (<a class="external text" href="http://msdn.microsoft.com/en-us/library/12a04hfd(v=vs.100).aspx" rel="nofollow">MSDN</a>), and thus volatiles may be used for inter-thread synchronization. Standard <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span></span> semantics are not applicable to multithreaded programming, although they are sufficient for e.g. communication with a <span class="t-lc"><a href="../utility/program/signal.html" title="cpp/utility/program/signal">std::signal</a></span> handler that runs in the same thread when applied to <span class="t-c"><span class="mw-geshi cpp source-cpp">sig_atomic_t</span></span> variables.
</p>
<h3><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=20" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see"><span><a href="../../c/atomic/memory_order.html" title="c/atomic/memory order">C documentation</a></span> for <span class="t-dsc-see-tt"><span>memory order</span></span></div>
</td></tr>

</tbody></table>
<h3><span class="editsection">[<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=edit&amp;section=21" title="Edit section: External links">edit</a>]</span> <span class="mw-headline" id="External_links">External links</span></h3>
<ul><li> <a class="extiw" href="https://en.wikipedia.org/wiki/MOESI_protocol" title="enwiki:MOESI protocol">MOESI protocol</a>
</li></ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: let&#39;s find good refs on QPI, MOESI, and maybe Dragon </td></tr></tbody></table>
<ul><li> <a class="external text" href="../../../../www.cl.cam.ac.uk/~pes20/weakmemory/cacm.pdf" rel="nofollow">x86-TSO: A Rigorous and Usable Programmer&rsquo;s Model for x86 Multiprocessors</a> P. Sewell et. al., 2010
</li><li> <a class="external text" href="../../../../www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf" rel="nofollow">A Tutorial Introduction to the ARM and POWER Relaxed Memory Models</a> P. Sewell et al, 2012
</li><li> <a class="external text" href="../../../../researchspace.auckland.ac.nz/bitstream/handle/2292/11594/MESIF-2009.pdf" rel="nofollow">MESIF: A Two-Hop Cache Coherency Protocol for Point-to-Point Interconnects</a>  J.R. Goodman, H.H.J. Hum, 2009
</li></ul>

<!-- 
NewPP limit report
Preprocessor visited node count: 4035/1000000
Preprocessor generated node count: 12411/1000000
Post‐expand include size: 123976/2097152 bytes
Template argument size: 38875/2097152 bytes
Highest expansion depth: 18/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:2839-0!*!0!!en!*!* and timestamp 20180329042005 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from &quot;<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;oldid=99112">https://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;oldid=99112</a>&quot;                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div class="catlinks" id="catlinks"><div class="mw-normal-catlinks" id="mw-normal-catlinks"><a href="http://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="http://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div class="noprint" id="cpp-footer-base">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>Navigation</h5>
            <ul>
<li id="n-Support-us"><a href="http://www.cppreference.com/support" rel="nofollow">Support us</a></li><li id="n-recentchanges"><a accesskey="r" href="http://en.cppreference.com/w/Special:RecentChanges" title="A list of recent changes in the wiki [r]">Recent changes</a></li><li id="n-FAQ"><a href="http://en.cppreference.com/w/Cppreference:FAQ">FAQ</a></li><li id="n-Offline-version"><a href="http://en.cppreference.com/w/Cppreference:Archives">Offline version</a></li>            </ul>
        </div>
                        <div id="cpp-toolbox">
            <h5><span>Toolbox</span><a href="#"></a></h5>
            <ul>
<li id="t-whatlinkshere"><a accesskey="j" href="http://en.cppreference.com/w/Special:WhatLinksHere/cpp/atomic/memory_order" title="A list of all wiki pages that link here [j]">What links here</a></li><li id="t-recentchangeslinked"><a accesskey="k" href="http://en.cppreference.com/w/Special:RecentChangesLinked/cpp/atomic/memory_order" title="Recent changes in pages linked from this page [k]">Related changes</a></li><li id="t-upload"><a accesskey="u" href="http://upload.cppreference.com/w/Special:Upload" title="Upload files [u]">Upload file</a></li><li id="t-specialpages"><a accesskey="q" href="http://en.cppreference.com/w/Special:SpecialPages" title="A list of all special pages [q]">Special pages</a></li><li id="t-print"><a accesskey="p" href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;printable=yes" rel="alternate" title="Printable version of this page [p]">Printable version</a></li><li id="t-permalink"><a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;oldid=99112" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="http://en.cppreference.com/mwiki/index.php?title=cpp/atomic/memory_order&amp;action=info">Page information</a></li>            </ul>
        </div>
                        <div id="cpp-languages">
            <div><ul><li>In other languages</li></ul></div>
            <div><ul>
<li class="interwiki-de"><a href="http://de.cppreference.com/w/cpp/atomic/memory_order" hreflang="de" lang="de" title="cpp/atomic/memory order">Deutsch</a></li><li class="interwiki-es"><a href="http://es.cppreference.com/w/cpp/atomic/memory_order" hreflang="es" lang="es" title="cpp/atomic/memory order">Espa&ntilde;ol</a></li><li class="interwiki-fr"><a href="http://fr.cppreference.com/w/cpp/atomic/memory_order" hreflang="fr" lang="fr" title="cpp/atomic/memory order">Fran&ccedil;ais</a></li><li class="interwiki-it"><a href="http://it.cppreference.com/w/cpp/atomic/memory_order" hreflang="it" lang="it" title="cpp/atomic/memory order">Italiano</a></li><li class="interwiki-ja"><a href="http://ja.cppreference.com/w/cpp/atomic/memory_order" hreflang="ja" lang="ja" title="cpp/atomic/memory order">&#x65E5;&#x672C;&#x8A9E;</a></li><li class="interwiki-pt"><a href="http://pt.cppreference.com/w/cpp/atomic/memory_order" hreflang="pt" lang="pt" title="cpp/atomic/memory order">Portugu&ecirc;s</a></li><li class="interwiki-ru"><a href="http://ru.cppreference.com/w/cpp/atomic/memory_order" hreflang="ru" lang="ru" title="cpp/atomic/memory order">&#x420;&#x443;&#x441;&#x441;&#x43A;&#x438;&#x439;</a></li><li class="interwiki-zh"><a href="http://zh.cppreference.com/w/cpp/atomic/memory_order" hreflang="zh" lang="zh" title="cpp/atomic/memory order">&#x4E2D;&#x6587;</a></li>            </ul></div>
        </div>
            <ul id="footer-info">
                                    <li id="footer-info-lastmod"> This page was last modified on 14 February 2018, at 17:31.</li>
                                    <li id="footer-info-viewcount">This page has been accessed 301,908 times.</li>
                            </ul>
                    <ul id="footer-places">
                                    <li id="footer-places-privacy"><a href="http://en.cppreference.com/w/Cppreference:Privacy_policy" title="Cppreference:Privacy policy">Privacy policy</a></li>
                                    <li id="footer-places-about"><a href="http://en.cppreference.com/w/Cppreference:About" title="Cppreference:About">About cppreference.com</a></li>
                                    <li id="footer-places-disclaimer"><a href="http://en.cppreference.com/w/Cppreference:General_disclaimer" title="Cppreference:General disclaimer">Disclaimers</a></li>
                            </ul>
                                    <ul class="noprint" id="footer-icons">
                                    <li id="footer-poweredbyico">
                                            <a href="http://www.mediawiki.org/"><img alt="Powered by MediaWiki" height="31" src="../../../mwiki/skins/common/images/poweredby_mediawiki_88x31.png" width="88"></a>                                            <a href="http://qbnz.com/highlighter/"><img alt="Powered by GeSHi" height="31" src="../../../../upload.cppreference.com/mwiki/images/2/2b/powered_by_geshi_88x31.png" width="88"></a>                                            <a href="http://www.tigertech.net/referral/cppreference.com"><img alt="Hosted by Tiger Technologies" height="31" src="../../../../upload.cppreference.com/mwiki/images/9/94/powered_by_tigertech_88x31.png" width="88"></a>                                        </li>
                                </ul>
                        <div style="clear:both">
            </div>
            </div>
        </div>
        <!-- /footer -->
        



<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 2.261 secs. -->
	
<!-- Cached 20180329042005 -->

</body><!-- Online page at http://en.cppreference.com/w/cpp/atomic/memory_order --></html>